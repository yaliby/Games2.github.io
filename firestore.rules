rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function signedIn() {
      return request.auth != null;
    }

    function isAnonymousGuest() {
      return signedIn()
        && request.auth.token.firebase.sign_in_provider == 'anonymous';
    }

    function isOwner(uid) {
      return signedIn() && request.auth.uid == uid;
    }

    // "Guest" users are usually anonymous-auth users, so they are still authenticated.
    function canCreateOwnUser(uid) {
      return isOwner(uid) || isAdmin() || (isAnonymousGuest() && request.auth.uid == uid);
    }

    // Client-only admin mode: replace placeholder with your real Firebase Auth UID.
    function isAdmin() {
      return signedIn()
        && request.auth.uid in ['PUT_ADMIN_UID_HERE'];
    }

    function validUsername(name) {
      return name is string
        && name.size() >= 3
        && name.size() <= 18
        && name.matches('^[a-zA-Z0-9][a-zA-Z0-9_]*$');
    }

    function onlyKeys(allowed) {
      return request.resource.data.keys().hasOnly(allowed);
    }

    function hasAllKeys(required) {
      return request.resource.data.keys().hasAll(required);
    }

    function hasKey(key) {
      return request.resource.data.keys().hasAny([key]);
    }

    function resourceHasKey(key) {
      return resource.data.keys().hasAny([key]);
    }

    function changedKey(key) {
      return request.resource.data.diff(resource.data).changedKeys().hasAny([key]);
    }

    function changedKeysOnly(allowed) {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(allowed);
    }

    function validScore(score) {
      return score is int
        && score >= 0
        && score <= 9007199254740991;
    }

    function validSeasonId(seasonId) {
      return seasonId is int && seasonId >= 1;
    }

    function validUpdatedAtNow() {
      return request.resource.data.updatedAt == request.time;
    }

    function validImageDataUrl(dataUrl) {
      return dataUrl is string
        && dataUrl.size() >= 40
        && dataUrl.size() <= 620000
        && dataUrl.matches('^data:image\\/(png|jpeg|jpg|webp);base64,.*$');
    }

    function validOptionalImageDataUrl() {
      return !hasKey('imageDataUrl') || validImageDataUrl(request.resource.data.imageDataUrl);
    }

    function validRemotePhotoUrl(url) {
      return url is string
        && url.size() >= 8
        && url.size() <= 2048
        && url.matches('^https?://[^\\s]+$');
    }

    function validProfilePhotoValue(value) {
      return value == ''
        || validRemotePhotoUrl(value)
        || validImageDataUrl(value);
    }

    function validSeasonalScoreCreate() {
      return hasAllKeys(['username', 'score', 'seasonId', 'updatedAt'])
        && onlyKeys(['username', 'score', 'seasonId', 'updatedAt'])
        && validUsername(request.resource.data.username)
        && validSeasonId(request.resource.data.seasonId)
        && validScore(request.resource.data.score)
        && validUpdatedAtNow();
    }

    function validSeasonalScoreUpdate() {
      return hasAllKeys(['username', 'score', 'seasonId', 'updatedAt'])
        && onlyKeys(['username', 'score', 'seasonId', 'updatedAt'])
        && validUsername(request.resource.data.username)
        && validSeasonId(request.resource.data.seasonId)
        && validScore(request.resource.data.score)
        && validUpdatedAtNow()
        && request.resource.data.updatedAt > resource.data.updatedAt
        && request.resource.data.seasonId >= resource.data.seasonId
        && (
          (request.resource.data.seasonId == resource.data.seasonId
            && request.resource.data.score >= resource.data.score)
          ||
          (request.resource.data.seasonId > resource.data.seasonId)
        );
    }

    match /usernames/{username} {
      allow read: if true;
      allow create: if canCreateOwnUser(request.resource.data.uid)
        && validUsername(username)
        && hasAllKeys(['uid'])
        && (onlyKeys(['uid']) || onlyKeys(['uid', 'createdAt']))
        && request.resource.data.uid is string
        && request.resource.data.uid == request.auth.uid
        && (!hasKey('createdAt') || request.resource.data.createdAt == request.time);
      allow update, delete: if isAdmin();
    }

    match /users/{uid} {
      allow read: if true;

      allow create: if canCreateOwnUser(uid)
        && hasAllKeys(['username', 'createdAt', 'bestScore', 'gamesPlayed'])
        && onlyKeys(['username', 'photoURL', 'createdAt', 'bestScore', 'gamesPlayed', 'achievements'])
        && validUsername(request.resource.data.username)
        && request.resource.data.createdAt == request.time
        && validScore(request.resource.data.bestScore)
        && request.resource.data.gamesPlayed is int
        && request.resource.data.gamesPlayed >= 0
        && (!hasKey('photoURL') || validProfilePhotoValue(request.resource.data.photoURL))
        && (!hasKey('achievements') || request.resource.data.achievements is list);

      allow update: if (isOwner(uid) || isAdmin())
        && changedKeysOnly(['username', 'photoURL', 'bestScore', 'gamesPlayed', 'achievements'])
        && (!changedKey('username') || validUsername(request.resource.data.username))
        && (!changedKey('bestScore') || (
              validScore(request.resource.data.bestScore)
              && request.resource.data.bestScore >= resource.data.bestScore
            ))
        && (!changedKey('gamesPlayed') || (
              request.resource.data.gamesPlayed is int
              && request.resource.data.gamesPlayed >= resource.data.gamesPlayed
            ))
        && (!changedKey('photoURL') || validProfilePhotoValue(request.resource.data.photoURL))
        && (!changedKey('achievements') || request.resource.data.achievements is list);

      allow delete: if isOwner(uid) || isAdmin();
    }

    match /achievements/{achievementId} {
      allow read: if true;
      allow write: if false;
    }

    match /scores/block-blast/users/{uid} {
      allow read: if true;
      allow create: if (isOwner(uid) || isAdmin()) && validSeasonalScoreCreate();
      allow update: if (isOwner(uid) || isAdmin()) && validSeasonalScoreUpdate();
      allow delete: if isOwner(uid) || isAdmin();
    }

    match /scores/word-guess/users/{uid} {
      allow read: if true;
      allow create: if (isOwner(uid) || isAdmin()) && validSeasonalScoreCreate();
      allow update: if (isOwner(uid) || isAdmin()) && validSeasonalScoreUpdate();
      allow delete: if isOwner(uid) || isAdmin();
    }

    match /scores/which-country/users/{uid} {
      allow read: if true;
      allow create: if (isOwner(uid) || isAdmin()) && validSeasonalScoreCreate();
      allow update: if (isOwner(uid) || isAdmin()) && validSeasonalScoreUpdate();
      allow delete: if isOwner(uid) || isAdmin();
    }

    match /scores/which-country-speedrun/users/{uid} {
      allow read: if true;
      allow create: if (isOwner(uid) || isAdmin())
        && hasAllKeys(['username', 'timeMs', 'updatedAt'])
        && onlyKeys(['username', 'timeMs', 'countriesFound', 'countriesTotal', 'updatedAt'])
        && validUsername(request.resource.data.username)
        && validScore(request.resource.data.timeMs)
        && request.resource.data.updatedAt == request.time
        && (!hasKey('countriesFound') || (
              request.resource.data.countriesFound is int
              && request.resource.data.countriesFound >= 0
              && request.resource.data.countriesFound <= 1000
            ))
        && (!hasKey('countriesTotal') || (
              request.resource.data.countriesTotal is int
              && request.resource.data.countriesTotal > 0
              && request.resource.data.countriesTotal <= 1000
            ))
        && (
              (!hasKey('countriesFound') && !hasKey('countriesTotal'))
              || (hasKey('countriesFound') && hasKey('countriesTotal')
                && request.resource.data.countriesFound <= request.resource.data.countriesTotal)
            );

      allow update: if (isOwner(uid) || isAdmin())
        && hasAllKeys(['username', 'timeMs', 'updatedAt'])
        && onlyKeys(['username', 'timeMs', 'countriesFound', 'countriesTotal', 'updatedAt'])
        && validUsername(request.resource.data.username)
        && validScore(request.resource.data.timeMs)
        && request.resource.data.updatedAt == request.time
        && (!hasKey('countriesFound') || (
              request.resource.data.countriesFound is int
              && request.resource.data.countriesFound >= 0
              && request.resource.data.countriesFound <= 1000
            ))
        && (!hasKey('countriesTotal') || (
              request.resource.data.countriesTotal is int
              && request.resource.data.countriesTotal > 0
              && request.resource.data.countriesTotal <= 1000
            ))
        && (
              (!hasKey('countriesFound') && !hasKey('countriesTotal'))
              || (hasKey('countriesFound') && hasKey('countriesTotal')
                && request.resource.data.countriesFound <= request.resource.data.countriesTotal)
            );

      allow delete: if isOwner(uid) || isAdmin();
    }

    match /scores/{game}/users/{uid} {
      allow read: if true;
      allow create, update: if (isOwner(uid) || isAdmin())
        && game != 'block-blast'
        && game != 'word-guess'
        && game != 'which-country'
        && game != 'which-country-speedrun'
        && hasAllKeys(['username', 'score'])
        && onlyKeys(['username', 'score', 'updatedAt'])
        && validUsername(request.resource.data.username)
        && validScore(request.resource.data.score)
        && (!hasKey('updatedAt') || request.resource.data.updatedAt is timestamp);
      allow delete: if (isOwner(uid) || isAdmin())
        && game != 'block-blast'
        && game != 'word-guess'
        && game != 'which-country'
        && game != 'which-country-speedrun';
    }

    match /feedback/{messageId} {
      allow read: if true;

      allow create: if signedIn()
        && hasAllKeys(['uid', 'username', 'kind', 'text', 'createdAt'])
        && onlyKeys(['uid', 'username', 'kind', 'text', 'imageDataUrl', 'createdAt'])
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.username is string
        && request.resource.data.username.size() >= 1
        && request.resource.data.username.size() <= 32
        && request.resource.data.kind in ['bug', 'idea', 'other']
        && request.resource.data.text is string
        && request.resource.data.text.size() >= 4
        && request.resource.data.text.size() <= 600
        && validOptionalImageDataUrl()
        && request.resource.data.createdAt == request.time;

      allow update, delete: if isAdmin();
    }

    match /suggestions/{suggestionId} {
      allow read: if true;

      allow create: if signedIn()
        && hasAllKeys(['uid', 'username', 'text', 'votesCount', 'voters', 'createdAt', 'updatedAt'])
        && onlyKeys(['uid', 'username', 'text', 'imageDataUrl', 'votesCount', 'voters', 'createdAt', 'updatedAt'])
        && request.resource.data.uid == request.auth.uid
        && validUsername(request.resource.data.username)
        && request.resource.data.text is string
        && request.resource.data.text.size() >= 4
        && request.resource.data.text.size() <= 600
        && validOptionalImageDataUrl()
        && request.resource.data.votesCount == 0
        && request.resource.data.voters is list
        && request.resource.data.voters.size() == 0
        && request.resource.data.createdAt == request.time
        && request.resource.data.updatedAt == request.time;

      allow update: if signedIn()
        && hasAllKeys(['uid', 'username', 'text', 'votesCount', 'voters', 'createdAt', 'updatedAt'])
        && onlyKeys(['uid', 'username', 'text', 'imageDataUrl', 'votesCount', 'voters', 'createdAt', 'updatedAt'])
        && resource.data.uid is string
        && resource.data.username is string
        && resource.data.text is string
        && resource.data.votesCount is int
        && resource.data.voters is list
        && resource.data.createdAt is timestamp
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.username == resource.data.username
        && request.resource.data.text == resource.data.text
        && (
              (!resourceHasKey('imageDataUrl') && !hasKey('imageDataUrl'))
              || (resourceHasKey('imageDataUrl')
                && request.resource.data.imageDataUrl is string
                && request.resource.data.imageDataUrl == resource.data.imageDataUrl)
            )
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.votesCount is int
        && request.resource.data.votesCount == resource.data.votesCount + 1
        && request.resource.data.voters is list
        && request.resource.data.voters.size() == resource.data.voters.size() + 1
        && request.resource.data.voters.hasAll(resource.data.voters)
        && !(request.auth.uid in resource.data.voters)
        && request.auth.uid in request.resource.data.voters
        && request.resource.data.updatedAt == request.time;

      allow delete: if (resource.data.uid is string && isOwner(resource.data.uid)) || isAdmin();
    }

    match /system/weekly {
      allow read: if true;

      allow create: if signedIn()
        && hasAllKeys(['seasonId', 'lastReset', 'nextReset'])
        && onlyKeys(['seasonId', 'lastReset', 'nextReset'])
        && request.resource.data.seasonId == 1
        && request.resource.data.lastReset is timestamp
        && request.resource.data.nextReset is timestamp
        && request.resource.data.lastReset <= request.time
        && request.resource.data.nextReset > request.resource.data.lastReset;

      allow update: if signedIn()
        && hasAllKeys(['seasonId', 'lastReset', 'nextReset'])
        && onlyKeys(['seasonId', 'lastReset', 'nextReset'])
        && resource.data.seasonId is int
        && resource.data.lastReset is timestamp
        && resource.data.nextReset is timestamp
        && request.resource.data.seasonId is int
        && request.resource.data.lastReset is timestamp
        && request.resource.data.nextReset is timestamp
        && request.resource.data.seasonId == resource.data.seasonId + 1
        && request.time >= resource.data.nextReset
        && request.resource.data.lastReset > resource.data.lastReset
        && request.resource.data.lastReset <= request.time
        && request.resource.data.nextReset > request.resource.data.lastReset;

      allow delete: if false;
    }
  }
}
